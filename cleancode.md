# Clean Code

## Chapter 2 의미 있는 이름

> 이제는 멤버 변수에 m_이라는 접두어를 붙일 필요도 없다.

- 클래스와 함수는 접두어가 필요없을 정도로 작아야 마땅하다.
- 멤버 변수를 다른 색상으로 표시하거나 눈에 띄게 보여주는 IDE를 사용해야 마땅하다.

멤버를 다른 색상으로 표시하는 IDE는 두말할 것 없이 마땅하다.

글과 달리, 나는 멤버 앞에 _ 붙이는 게 좋다. 멤버 변수와 메서드 내의 변수가 모호해지는 일이 자주 생기기 때문이다. 하지만 이 글에 따라, 메서드 내의 변수가 멤버 변수와 중복되는 로직이 생기면, 그 로직은 이 클래스의 밖에 있어야 한다? 왠지 이쪽이 맞는 것 같다. 중복되는 예를 보면서 생각해볼 필요가 있다.

> (개인적으로) 접두어 I는 주의를 흩트리고 과도한 정보를 제공한다.

인터페이스와 클래스는 매우 다르다고 생각한다. 읽을 때는 거기서 거기이거나, 주의를 흩트릴 수도 있겠지만, 무엇을 상속할지를 결정할 때에 그 정보가 필요하다. 그렇다면 이건 과도한 정보를 제공하는 것이 아니다.

구현과 인터페이스 중 하나를 인코딩한다면 구현을 인코딩해야 한다는 데에는 동의한다. 인터페이스쪽이 조금 더 추상적인 개념으로서 인지에 가깝다. 구현은 더 숨길 필요가 있다. 그럼에도 나는 I인코딩을 사용한다. 표준 라이브러리와 인코딩을 혼용할 수는 없기 때문이다. 다른 인코딩은 괜찮더라도 클래스/인터페이스 인코딩은 혼용하면 잘못된 정보가 제공되기 쉽겠다.

> 좋은 이름을 선택하려면 설명하는 능력이 뛰어나야 하고 문화적인 배경이 같아야 한다.

좋은 이름은 상대적이라는 생각이 든다.

## Chapter 3 함수

> 함수의 인수 개수가 4개 이상이 되려면 특별한 이유가 필요하다. 특별한 이유가 있어도 사용하면 안된다.

> 플래그 인수는 추하다. 함수로 부울 값을 넘기는 관례는 정말로 끔찍하다.

모두 Named arguments에는 적용이 되지 않을 것이다. 너무 익숙해져서 이게 없는 언어는 사용하기 힘들어졌다. 단, 인수 개수를 되도록 줄여야 한다는 건 변하지 않는다.

수업에서 많은 인수들의 타입이 같을 때 Named arguments를 사용하라고 했다. Flag가 이에 해당하는 예시일 것이다. 타입이 다른 인수들에 대해서는 Named arguments의 가치가 조금 떨어질까? 내 생각엔 같은 추상화 수준에 있는 것들이면, 타입 상관없이 똑같이 효율적일 것이다. 함수가 어떻게 동작할지 결정해주는 Boolean flag 와, 마찬가지인 Enum, Int가 Named arguments로 묶이는 건 바람직하다. 교수님도 같은 타입이라기보단 같은 추상화 수준을 생각하셨을 것이다.

만약 Named Argument가 1개라면 이를 명시적으로 분리한 Overload된 두 함수를 만드는 것이 좋을 것 같다. 만약 서로 다른 추상화수준의 여러개라면 더 깊은 수준의 것을 Struct로 묶어서 한 수준으로 맞춰야 할 것이다.

> 오류를 처리하는 함수는 오류만 처리해야 마땅하다. 함수에 키워드 try가 있다면 함수는 try 문으로 시작해서 catch/finally로 끝나야 한다는 말이다.

이건 생각해보지 못했다. 맞는 말이다. Delete가 있으면, TryDelete를 분리해서 쓴 적이 있다.

## Chapter 4 주석

결국 주석의 의의는 의도를 설명하는 것으로 귀결된다.

주석은 코드가 할 수 없는 역할을 수행한다. 주석은 함수가 존재하는 의도, 함수가 이렇게 생겨먹은 의도, 그리고 함수를 사용하거나 수정할 때 바라는 것들을 전달할 수 있다. TODO도, 중요성 강조도, 결과를 경고하는 주석도 이에 해당된다.

공개 API에서는 각 API의 역할을 적어놓아야 할 것이다. 사용자가 API에게 어떤 로직을 수행하기를 기대할 때 이 함수를 써라, 똑같은 말이지만 거꾸로 말해서, 각 함수를 사용할 때 사용자에게 기대하는 것을 적어야 한다. 이는 아무리 잘 짠 코드라도 주석(Javadocs)이 없다면 전달할 수 없다.

```java
catch(SocketException e)
{
	// 정상. 누군가 요청을 멈췄다.
}
```

Ignore() 함수를 만든 적이 있다. 이 함수 내부를 들여다보면 주석만 덜렁 있는데, 이 함수를 catch 블록 안에 넣으면, 아무 것도 수행하지 않기를 의도했다는 걸 알릴 수 있다고 적혀있다. 이 함수는 의도를 설명하는 주석이다. Python의 pass 키워드와 같다. catch 블록이 왜 아무것도 수행하지 않는지를 함께 적으면 더 좋을 것이다.

```scala
import Common.Util.NamedParamForced._

class Context(x: NamedParam = Forced, workerCount: Int, ...
```

Scala 공부하면서 봤던 재미있는 코드이다. Stack overflow에서 코드를 처음 봤을 때에는 NamedParam과 Forced가 각각 foo, bar였지만, 내가 작명했다. 이 코드는 컴파일 타임에 동작하는 기능도 있지만, 주석으로서의 역할을 더 훌륭할 수 없이 해내고 있다.

> // 배열에 있는 모든 배수는 배열 크기의 제곱근보다 작은 소수의 인수다.
// 따라서 이 제곱근보다 더 큰 숫자의 배수는 제거할 필요가 없다.

좋은 주석의 예시에 있던 것이다. Loop invariant를 나타내고 있다. Loop invariant는 재귀 코드를 이해하려면 반드시 필요한 것이지만, 코드의 표면에서 가시화되지 않기 때문에 설명할 필요가 있다. 몇몇 언어는 이를 지원해서, 이것도 코드로 바꿀 수 있을 것이다.

## Chapter 7 오류 처리

> Checked exception은 Open Closed Principle을 위반한다. 메소드에서 확인된 예외를 던졌는데 catch 블록이 세 단계 위에 있다면 그 사이 메소드가 모두 선언부에 그 예외를 정의해야 한다. 즉, 하위 단계에서 코드를 변경하면 상위 단계 메소드 선언부를 전부 고쳐야 한다는 소리다.

여기에는 동의하기 어렵다. 메소드가 던지는 예외가 늘어났다면 그건 분명 메소드의 동작이 바뀐 것이기 때문에 코드가 수정되는 것이 합당하다.

최하위 함수에서 던지는 예외를 가장 바깥의 것들이 알아야 하므로 캡슐화가 깨진다는 주장에 대해서는 Unchecked의 필요성을 동의한다. 최심부에 나눗셈을 하나 추가하려는데, DivideByZero를 프로그램 최외곽에 있는 catch가 잡게 하고 싶어질 때는 있을 것이다.

하지만 나는 어떤 함수를 호출하던간에, 적혀있지 않은 예외가 언제 등장할지 모르기 때문에 항상 두렵다. 적어도 원하는 영역에 한해 (특히 High order function이 아닌 경우) Checked exception을 선택적으로 적용할 수 있게 하는 것이 옳다고 생각한다. 강제된 Unchecked는 TDD를 유도하는 덫일 뿐이다.

> null을 반환하지 마라

> null을 전달하지 마라

C# 8.0 Nullable reference type을 연습삼아 사용해봤는데, 이렇게 좋은 걸 왜 안 쓰나 하는 생각이 든다. 이름과는 달리 ref에 기본적으로 null을 허용하지 않는 기능이다. Null은 보통의 초기화 로직에서 피할 수 없는데, 모든 멤버 변수를 immutable (C# 키워드 readonly)로 선언해서 최대한 회피했다. 회피라기보다는, 이쪽이 더 인지에 들어맞았다. 인지에 들어맞지 않는 경우가 있다면, 우리 사고 회로가 null에 너무 익숙해진 탓일 것이다.

> 교수님: 예외적으로 exception의 종류가 너무 많을 경우 int를 리턴코드로 쓰자

별로 동의하지 않는다. Exception의 종류가 너무 많다는 건 무엇을 의미하는가? 그 모든 상황을 처리할 로직이 복잡해지는 것을 피할 수 없다는 이야기이다. 다른 방법을 찾는 것은 문제를 간단하게 만들어주지 않는다.

별개의 이야기이지만, 리턴코드에 대해서는 int보단 타입 체크가 있는 enum이 무조건 좋고, enum보단 패턴매칭이 가능한 case class가 좋고, case class보단 더 상위 함수가 받을 수도 있는 checked exception이 좋다. Unchecked는 모르겠다..

## Chapter 9 단위 테스트

> TDD 법칙

1. 실패하는 단위 테스트를 작성할 때까지 실제 코드를 작성하지 않는다.
2. 컴파일은 실패하지 않으면서 실행이 실패하는 정도로만 단위 테스트를 작성한다.
3. 현재 실패하는 테스트를 통과할 정도로만 실제 코드를 작성한다.

테스트를 대충 짜면 심각한 관리 문제를 만날지도 모른다. 실제 코드보다 테스트를 짜는 데에 시간이 더 걸릴 수 있지만, 그렇다고 퀄리티를 포기하면 테스트 수트를 다시 처음부터 만들지도 모른다.

문제가 있다. 유닛 테스트를 촘촘하게 만들지 않는데도 유닛 테스트만 믿고 프로덕션 코드에 소홀하게 될 수 있다. 애자일에서는 그다지 중요하지 않은 문제일 수도 있겠지만, 일반적으로 큰 문제가 될 것이다.

TDD 전반에 대해 거론되는 이야기이지만, 이 원칙에서는 문제가 명확하게 보인다. 보통은 프로덕션 코드에 소홀하지 않으면 된다 라던가, 테스트는 없는 것보다 있는 게 좋다는 것을 근거로 커버 칠 수 있지만, 2번과 3번의 관계는 문제가 있다.

> BUILD-OPERATE-CHECK 패턴

테스트 코드는 실제 코드보다도 가독성이 중요하다.

> 테스트당 개념 하나

각 개념마다 테스트를 만들자. 중복되는 코드가 많아질 수도 있지만, 코드 이해가 쉽고 빠르다. 이걸 잘 따르면 개념 당 assert 수가 최소로 줄어들게 된다.

하나의 테스트에 여러 개념을 묶으면, 테스트 코드의 각 부분이 그곳에 존재하는 이유를 알기 어렵다.

> FIRST

- Fast
- Independent
- Repeatable
- Self-Validating
- Timely

빠르게 돌아가서 자주 돌릴 수 있게. 독립적이어서 잇달아 실패하여 원인을 진단하기 곤란해지지 않게. 반복 가능하게. 스스로 성공 실패를 판단하게. 실제 코드가 복잡해져서 테스트 코드를 짜기 곤란하기 전에.

> 이중  표준

테스트 코드에 적용하는 표준은 실제 코드에 적용하는 표준과 다르다. 무엇보다도 효율적일 필요가 없다.

> 교수님: 유닛 테스트 코드는 버려도 된다

이견이 있을 수 있다고 했다. 유닛 테스트는 다시 쓸 일이 없다고 했다.

나는 테스트의 목적이 리팩토링에 있다고 생각한다. 유닛 테스트가 없다면 리팩토링이 불가능한 코드가 될 것이다.

## Chapter 10 클래스

> 응집도를 유지하면 작은 클래스 여럿이 나온다

클래스를 쪼갤지 말지에 대한 기준이 필요하다고 종종 생각했다.

> 변경으로부터 격리

상세한 구현에 의존하는 클라이언트 클래스는 구현이 바뀌면 위험에 빠진다. 상세한 구현에 의존하는 코드는 테스트가 어렵다. 더미 클래스를 만들 수 있도록 인터페이스를 분리하자. 의존성 주입은 덤이다.

> Inheritance violates encapsulation. A subclass depends on the implementation details of its superclass for its proper function.

정말 맞는 말인데 생각해본 적이 없다.
