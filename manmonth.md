# The Mythical Man-Month

## Chapter 1 타르 구덩이

차고에서 만들어진 프로그램은 "제품"이나 "시스템"이 되면 3배, 둘다는 9배의 비용이 든다.

프로그래밍은 고달프다.

- 완벽함이 요구된다.
- 내 목표와 자원을 타인이 결정한다.
- 제품이 완성되었을 때 이미 한물간 것으로 치부될 수 있다.

## Chapter 2 맨먼스 미신

모든 프로그래머는 낙관론자다.

커뮤니케이션 오버헤드는 무시무시하다. 인원을 늘리지 말자.

어차피 테스트에 절반의 시간을 쓴다.

전체 개발 기간은 코딩의 6배 정도가 됨.

일정 붕괴에는 악순환이 있다.

이렇게 많은 이유로, 프로젝트를 맨먼스로 바라보는 미신을 버리자.

## Chapter 3 외과 수술 팀

커뮤니케이션 오버헤드를 줄이는 방법으로 Surgical Team이 있다. 의견 상충 해결은 사실 부차적이다.

## Chapter 4 귀족 정치, 민주주의, 시스템 설계

설계의 통일성과 개념적 일관성이 사용의 용이성을 가져온다. 따라서 귀족 정치는 좋다.

구현 담당에게 불만이 있을 수도 있는데, 구현도 설계만큼 창조적이니까 걱정할 필요 없다. 구현과 분리된 설계로부터 구현에 대한 제약이 생기는데, 그 제약만큼 더 창조적일 수가 있다.

## Chapter 5 두번째 시스템 효과

구현 과정에서 창의성을 발휘할 책임은 구현자에게 있다.

아키텍처의 두번째 버전은 자기절제가 필요하다.

- 기능적인 장식이 너무 많다.
- 시스템의 전제와 목적이 변한 것을 반영하지 못한다.

## Chapter 6 말을 전하다

매뉴얼은 아키텍트의 가장 주요한 산출물이다.

사용자는 종종 항목 하나만 참조할 것이므로, 각 항목에는 필요한 내용을 빠짐없이 반복하되 그 모두가 전체적으로 일치되어야 한다.

구현체에 의한 설계 정의 ⇒ 무효한 동작에서 비롯되는 부작용이 있을지도 모른다.

아키텍트, 사용자, 구현자로 구성된 집단이 매주 작고 빠른 회의를 하고, 나중에 불만사항들을 묶은 백로그를 모아서 큰 회의를 할 수 있다.

매뉴얼이랑 구현체랑 불일치할 때 싸우면 보통 매뉴얼이 진다. 이걸 막으려고 구현체를 두어개 만들기까지 한다.

## Chapter 7 바벨탑은 왜 실패했는가?

> 내일의 제품 매뉴얼은 오늘의 메모에서 비롯된다.

> 프로그래머는 자기 담당이 아닌 부분의 세부 내용에 노출될 때가 아니라, 그로부터 차단될 때에 가장 효율적이다

요새는 워크북이 온라인으로 실시간으로 공유되므로, 이 환경을 이용하는 게 중요한 것 같다. 하이퍼링크를 통해 소스와 워크북을 왕복 가능한 유틸리티를 쓰는 그룹을 본 적이 있다.

## Chapter 8 예고 홈런

> 실제 프로그래밍과 디버깅에 쓸 수 있었던 시간은 전체의 50%밖에 되지 않았다.

## Chapter 9 5파운드 자루에 담은 10파운드

속도 우선 버전과 공간 우선 버전 두 벌의 서브루틴을 준비한다? 지금도 해당되는 이야기인지는 모르겠다.

## Chapter 10 기록물 가설

> 오로지 글로 적을 때에만 빠진 곳이 나타나고 모순들이 드러난다.

## Chapter 11 버리기 위한 계획

> 버리기 위한 계획을 세우라. 어쨌거나 버리게 될 것이다.

> 조직 구조가 위압적인 상황이라면,완벽한 방어가 가능해질 때까지 그 어떤 내용도 문서화되지 않을 것이다.

> 규모가 큰 프로젝트의 관리자라면 최고의 프로그래머 두세 명을 전투가 가장 치열한 곳에 구조하러 달려갈 기마병으로 예비해 두어야 한다.

## Chapter 13 전체 그리고 부분들

- 보라색 배선 기법이 필요하다.
- 구성 요소 추가는 한 번에 하나씩
- 변경은 묶음으로

위 사항들은 현재의 git 브랜치 관리 철학에 대응된다.

## Chapter 14 재앙의 알을 품다

마일스톤은 구체적이고 명확하고 측정 가능한 이벤트여야 하며, 날이 선 듯이 분명하게 정의되어야 한다.

일정이 하루 지연되었다 해도 흥분해야만 한다. 자기가 맡은 부분이 임계 경로로 빠지지 않기 위해서 허슬이 필요하다.

문제 보고를 감추려 한다. 문제를 피하기 위해 보스는 역할 갈등을 줄이고 상황 공유를 장려해야 한다. 보스는 각종 회의와 회고를 상황 점검과 문제 해결로 나누고, 스스로를 통제해야 한다.

숙련된 인원들을 경미한 지연을 드러내는 자리에 배치하는 것은 상당한 보상을 가져다준다.

## Chapter 16 은 탄환은 없다

> 소프트웨어 개발에서 가장 힘든 부분은 완전하고 일관된 명세이며, 프로그램 작성의 핵심 대부분은 사실 명세를 디버깅하는 일이다.

소프트웨어를 구축하지 말고 성장시키면  하향식 설계가 되며 사기에 영향을 준다.
